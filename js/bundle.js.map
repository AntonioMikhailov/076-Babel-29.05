{"version":3,"file":"bundle.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,2BAA2B;AAC3B;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,eAAe,UAAU,MAAM,SAAS;AACxC,sCAAsC,WAAW;AACjD,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,uCAAuC,IAAI,WAAW,WAAW,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA,OAAO;AACP,IAAI;AACJ;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA,KAAK;AACL,MAAM;AACN;AACA;AACA;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,EAAE;AACF;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,2BAA2B;AAC3B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,2CAA2C;AAC3C,qCAAqC;AACrC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAA8C;AACnE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,CAAC,eAAe;AAChB;AACA,CAAC,iBAAiB;AAClB;AACA,CAAC;AACD,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,EAAE;AACF;AACA;AACA,yDAAyD;AACzD;AACA;AACA,iDAAiD;AACjD,wDAAwD;AACxD,8DAA8D;AAC9D;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,oCAAoC;AACpC,6CAA6C;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,EAAE;AACnC;AACA,OAAO;AACP,gCAAgC,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC,SAAS;AACT,kCAAkC,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN,qCAAqC;AACrC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,CAAC;AACD;AACA;AACA;AACA;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,wDAAwD;AACxD;AACA;AACA,8CAA8C;AAC9C,wBAAwB;AACxB;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;;;;;UC/DA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;ACtBA;AACA,WAAW,mBAAO,CAAC,4CAAgB;AACnC,YAAY,mBAAO,CAAC,8CAAiB;AACrC,YAAY,mBAAO,CAAC,8CAAiB;AACrC,YAAY,mBAAO,CAAC,8CAAiB;AACrC,aAAa,mBAAO,CAAC,gDAAkB;AACvC,YAAY,mBAAO,CAAC,8CAAiB;;;AAGrC;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,GAAG,c","sources":["webpack://056-11.05-fetch/./js/modules/cards.js","webpack://056-11.05-fetch/./js/modules/forms.js","webpack://056-11.05-fetch/./js/modules/modal.js","webpack://056-11.05-fetch/./js/modules/slider.js","webpack://056-11.05-fetch/./js/modules/tabs.js","webpack://056-11.05-fetch/./js/modules/timer.js","webpack://056-11.05-fetch/webpack/bootstrap","webpack://056-11.05-fetch/./js/script.js"],"sourcesContent":["function cards() { \r\n \r\n// Классы для карточек урок 48\r\n// Что нужно для карточки - путь к фото, алт.текст для фото, заголовок, описание, цена в долларах\r\n// Создаем те свойства которые будут меняться с сервера. Размеры будут те же. Класс будет создавать только верстку\r\nclass MenuCard {\r\n  constructor(src, alt, title, descr, price, parentSelector, ...classes) {\r\n    this.src = src;\r\n    this.alt = alt;\r\n    this.title = title;\r\n    this.descr = descr;\r\n    this.price = price;\r\n    this.classes = classes;\r\n    this.parent = document.querySelector(parentSelector);\r\n    this.transfer = 27; // пример курса рубля\r\n    this.changeToRouble(); // вызываем метод прямо в констр.\r\n  }\r\n  changeToRouble() { // метод перевода из дол. в рубли\r\nthis.price = this.price * this.transfer;\r\n  }\r\n  render() { // создает верстку в виде элементов\r\n    const element = document.createElement('div');\r\n    // если доп. классы не передадутся мы сами их добавим\r\n    if(this.classes.length ==0) {element.classList.add('menu__item');} \r\n    // добавляем класс селектор через оператор rest ( classes) - их может быть несколько  - поэтому через цикл\r\n    this.classes.forEach(itemClass => { \r\n      element.classList.add(itemClass); \r\n     });\r\n    // внутрь пустого div вставляем образец верстки из HTML\r\n    element.innerHTML = `\r\n    <img src=${this.src} alt=${this.alt}>\r\n    <h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n    <div class=\"menu__item-descr\">${this.descr}</div>\r\n    <div class=\"menu__item-divider\"></div>\r\n    <div class=\"menu__item-price\">\r\n        <div class=\"menu__item-cost\">Цена:</div>\r\n        <div class=\"menu__item-total\"><span>${this.price}</span> грн/день</div>\r\n    </div>\r\n    `;\r\n    this.parent.append(element); // вставляем элемент внутрь родителя в конец\r\n  }\r\n}\r\n// импортируем данные карточек с сервера из файла db.json\r\nconst getResource = async (url)=> {\r\n  const res = await fetch(url);\r\n  if(!res.ok) { // если что то не так ( св-во ok или status)\r\n    throw new Error(`Could not fetch ${url}, status:${res.status}`); // Объект ошибки куда вставятся данные\r\n  }\r\n  return await res.json(); \r\n};\r\n// Первый вариант через Класс\r\n// getResource(' http://localhost:3000/menu')\r\n// .then(data => {\r\n//   // мы получаем массив карточек ( объектов) и перебираем их\r\n//   data.forEach(({img, altimg, title, descr, price}) => { \r\n//     //через деструктуризацию\r\n//     new MenuCard(img, altimg, title, descr, price, '.menu .container').render();\r\n//    });\r\n// });\r\n// вариант через библиотеку Axios\r\naxios.get(' http://localhost:3000/menu')\r\n.then(data => {\r\n    data.data.forEach(({img, altimg, title, descr, price}) => { \r\n      //через деструктуризацию\r\n      new MenuCard(img, altimg, title, descr, price, '.menu .container').render();\r\n    });\r\n     });\r\n}\r\n\r\nmodule.exports = cards;","function forms() { \r\n \r\n// Отправка Форм обратной связи через AJAX на локальный файл server.php\r\n// Находим все формы по тегу form 3шт\r\nconst forms = document.querySelectorAll('form');\r\n//кнопку в переменную не нужно т.к. form отправляет автоматом если кнликнуть по тегу button\r\n// создаем объект с списками фраз уведомлениями для юзера\r\nconst message =  {\r\n  loading: 'img/spinner.svg', //до отправки запроса\r\n  success: 'Спасибо! Скоро мы с Вами свяжемся',\r\n  failed: 'Что то пошло не так...'\r\n};\r\n//привязываем поля ввода к formData\r\nforms.forEach(item => { \r\n  bindpostData(item);  //вызываем функцию\r\n });\r\n// создаем отдельную ф. по общению с сервером\r\n// Важно сто код здесь асинхронный и мы не знаем сколько времени на ответ от сервера уйдет и код не ждет выполнения fetch() а идет дальше поэтому используем async/await ( всегда в паре)\r\nconst postData = async (url, data)=> {\r\n  const res = await fetch(url, { // await - значит будет ждать результат запроса и только потом продолжит выполнение\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-type': 'application/json'\r\n    },\r\n   body : data\r\n  });\r\n  return await res.json(); // возвращает Promise дальше в then - также нужен await\r\n};\r\nfunction bindpostData(form) {\r\n  form.addEventListener('submit', (e)=> {\r\n    e.preventDefault();  //отменяем перезагрузку\r\n    // создаем новый блок для spinner\r\n  let statusMessage = document.createElement('img');\r\n  statusMessage.src = message.loading;\r\n  statusMessage.style.cssText = ` \r\n  display: block;\r\n  margin: 0 auto;\r\n  `; \r\n  // но проще добавить класс в CSS\r\n // form.append(statusMessage); // добавили текст к форме\r\nform.insertAdjacentElement('afterend', statusMessage );\r\n    // Создаем метод отправки вариант XML Request - устаревший\r\n    // const request = new XMLHttpRequest();\r\n    // request.open('POST', 'server.php'); // метод и путь\r\nconst formData = new FormData(form); //получаем данные из input\r\n// можно так получить формат JSON из FormData\r\n// const object = {};\r\n// formData.forEach(function(value, key) { \r\n//   object[key] = value;\r\n//  });\r\n// или так - сначала превращаем в массив массивов а потом обратно в объект JSON\r\nconst json = JSON.stringify(Object.fromEntries(formData.entries()));\r\n// Применяем метод Fetch\r\npostData('http://localhost:3000/requests', json) // server.php уже не нужен если Json сервер\r\n.then(data => {\r\n  console.log(data); // те данные который возвращаются из Promise {\"name\":\"Антон\",\"phone\":\"+7911 291 0063\"}\r\n     //уведомляем юзера об успешной отправке его message\r\n     showThanksModal(message.success);\r\n       // После отправки формы очищаем поля и убираем надпись уведомление\r\n       setTimeout(() => {\r\n        statusMessage.remove();\r\n        }, 2000);\r\n}).catch(()=> { // сюда можно добавить еще then(), но  мы пропишем блок catch() если будет ошибка от ответа сервера\r\n  showThanksModal(message.failed);\r\n}).finally(()=> { // добавляем еще действие очистки формы - независимо от того как ответил сервер\r\n  form.reset();\r\n}); \r\n  });\r\n} // конец ф. PostData\r\n// Создаем окно благодарности после отправки формы вместо простых надписей. Будем использовать блок modal__dialog и внего вставлять новый контент\r\nfunction showThanksModal(message) { \r\n  const prevModalDialog = document.querySelector('.modal__dialog');\r\n  // прячем предыдущий контент с полями отправки\r\n  prevModalDialog.classList.add('hide');\r\n  openModal();\r\n // создаем новый контент в окне\r\n let thanksModal = document.createElement('div');\r\n thanksModal.classList.add('modal__dialog');\r\nthanksModal.innerHTML = `\r\n<div class= 'modal__content'>\r\n<div class='modal__close' data-close>&times;</div>\r\n<div class='modal-title'>${message}</div> \r\n</div>  \r\n`;\r\n// вставляем в верстку\r\ndocument.querySelector('.modal').append(thanksModal);\r\nsetTimeout(() => {\r\n  prevModalDialog.classList.remove('hide');\r\n  thanksModal.remove();\r\n  closeModal();\r\n}, 4000);\r\n}\r\n}\r\n\r\nmodule.exports = forms;","function modal() { \r\n // ++++ Модальные окна ++++++++++++++++++++++++++++++\r\nconst modal = document.querySelector('.modal');\r\nconst btnOpenModal = document.querySelectorAll('[data-modal]');\r\n// const btnCloseModal = document.querySelector('[data-close]');\r\n// Суть - автопоказ по скролу и по таймеру всего один раз при загрузке страницы. Если до этого автопоказа юзер сам вызвал модалку то автопоказ убирается навсегда. И потом юзер может только вручную вызывать модалку\r\n//ф. открытиф модалки\r\nfunction openModal() { \r\n  let offset =  window.outerWidth - window.innerWidth; // 16 px\r\n  modal.style.display = 'block';\r\n  document.body.style.overflow = 'hidden';\r\n  document.body.style.paddingRight = offset + 'px';\r\n  // убираем автопоказ если юзер сам кликнул и очищаем показ с задержкой и по скролу\r\n  window.removeEventListener('scroll', showModalByScroll);\r\n  // clearTimeout(showModalDelay);\r\n}\r\n// ф. закрытия модалки\r\nfunction closeModal() { \r\n  modal.style.display = 'none';\r\n     document.body.style.overflow = '';\r\n     document.body.style.paddingRight = 0 + 'px';\r\n     }\r\nbtnOpenModal.forEach(item => { \r\n  item.addEventListener('click', openModal);\r\n  // или так\r\n  // item.addEventListener('click', ()=> {\r\n  //   openModal();\r\n  // }); \r\n    // также если юзер сам кликнет по модалке то убираем ее показ с задержкой или промоткой до низа\r\n    window.removeEventListener('scroll', showModalByScroll);\r\n });\r\n // закрываем с помощью делегирования + event target\r\n//  modal.addEventListener('click', (e)=> { \r\n//    if(e.target == btnCloseModal|| e.target == modal ) {\r\n//     modal.style.display = 'none';\r\n//     document.body.style.overflow = '';\r\n//     document.body.style.paddingRight = 0 + 'px';\r\n//    }\r\n//  });\r\n // закрываем по Esc\r\n//  window.addEventListener('keydown', (e)=> { \r\n//    if (e.code === 'Escape') {\r\n//     modal.style.display = 'none';\r\n//     document.body.style.overflow = '';\r\n//     document.body.style.paddingRight = 0 + 'px';\r\n//    }\r\n//  });\r\n// Объединяем два события в одном слушателе\r\n ['click', 'keydown'].forEach(function(item) {\r\n   //именно document или window иначе по клавише не сработает\r\n  document.addEventListener(item, (e)=> { \r\n    // делаем ссработку клавиши Esc только когда открыто окно \r\n    if ( e.target == modal || (e.code == 'Escape' || e.target.getAttribute('data-close') == '' && modal.style.display !== 'none')) {\r\n      closeModal();\r\n    }\r\n });\r\n });\r\n  // Появление модалки при скроле до низа ( минус 300px) или после 10 секунд с начала входа на сайт\r\n  // Для этого создадим функциии открытия модалки и закрытия\r\n  // let showModalDelay = setTimeout( openModal, 50000); // убрал чтобы не мешало\r\n// ф. показа при скроле вниз\r\nfunction showModalByScroll() { \r\n  let scrollHeight = document.body.scrollHeight; // вся высота body\r\n    let scrollTop = document.documentElement.scrollTop; // прокрутка\r\n    let clientHeight = document.documentElement.clientHeight; // высота окна body\r\n    if(scrollHeight <= (scrollTop + clientHeight) + 100 ) {\r\n      // console.log(222);\r\n      clearTimeout(showModalDelay);\r\n      // openModal(); // закрыл чтобы не мешало\r\n}\r\n}\r\n  window.addEventListener('scroll', showModalByScroll);\r\n}\r\nmodule.exports = modal;","function slider() { \r\n  // Слайдер простой -061\r\n\r\n  const offerSlide = document.querySelectorAll('.offer__slide');\r\n  const sliderPrevBtn = document.querySelector('.offer__slider-prev');\r\n  const sliderNextBtn = document.querySelector('.offer__slider-next');\r\n  const currentNum = document.querySelector('#current');\r\n  const totalNum = document.querySelector('#total');\r\n  // Показываем первый слайд при загрузке\r\n  let indexSlide = 1; // у Ивана =1\r\n  // вариант 2 - Ивана\r\n  \r\n  showSlide(indexSlide); // показываем первый слайд\r\n  function showSlide(n) {\r\n    if(n > offerSlide.length){\r\n      indexSlide = 1; \r\n     } \r\n     if(n < 1) {\r\n       indexSlide = offerSlide.length;\r\n     } \r\n     offerSlide.forEach(item => { \r\n      item.classList.remove('active');\r\n      offerSlide[indexSlide-1].classList.add('active');\r\n     }); \r\n  }\r\n  //для того чтобы контролировать индекс, изменяем его значения при клике на кнопках - отсюда значение индекса пойдет дальше\r\n  function currentIndex(n) {\r\n    showSlide(indexSlide = indexSlide + n );\r\n    //здесь индекс передастся в остновную ф.showSlide\r\n   }\r\n  \r\n  sliderNextBtn.addEventListener('click', ()=> {\r\n    // currentIndex(indexSlide +1); // убираем\r\n    // showSlide(indexSlide  + 1 ); так не сработает\r\n    showSlide(indexSlide = indexSlide + 1 ); // так  - да\r\n    showCurrentNum(indexSlide);\r\n    });\r\n  sliderPrevBtn.addEventListener('click', ()=> { \r\n    // currentIndex(-1);\r\n    showSlide(indexSlide = indexSlide - 1 );\r\n  showCurrentNum(indexSlide);\r\n  });\r\n  \r\n  // функция показа Общего кол-ва номеров слайда\r\n  function showTotalNum() { \r\n    if(offerSlide.length < 10) {\r\n       totalNum.innerHTML = `0${offerSlide.length}`;\r\n      } else {\r\n       totalNum.innerHTML= offerSlide.length;\r\n      }\r\n   }\r\n   showTotalNum();\r\n   // ф. показа текущего номера\r\n   function showCurrentNum(n) { \r\n     if(n <= 9) {\r\n      currentNum.innerHTML = `0${n}`;\r\n      console.log(n);\r\n     } else {\r\n      currentNum.innerHTML = `${n}`;\r\n     }\r\n   }\r\n   showCurrentNum(indexSlide);\r\n  \r\n  \r\n  // function showSlide(n) {\r\n  //   offerSlide.forEach(item => { \r\n  //     item.classList.remove('active');\r\n  //     offerSlide[n].classList.add('active');\r\n  //    }); \r\n  // }\r\n  // showSlide(indexSlide);\r\n  // // функция показа Общего кол-ва номеров слайда\r\n  // function showTotalNum() { \r\n  //  if(offerSlide.length < 10) {\r\n  //     totalNum.innerHTML = `0${offerSlide.length}`;\r\n  //    } else {\r\n  //     totalNum.innerHTML= offerSlide.length;\r\n  //    }\r\n  // }\r\n  // showTotalNum();\r\n  // // ф. показа текущего номера\r\n  // function showCurrentNum(n) { \r\n  //   if(n <= 9) {\r\n  //    currentNum.innerHTML = `0${n+1}`;\r\n  //   } else {\r\n  //    currentNum.innerHTML = `${n+1}`;\r\n  //   }\r\n  // }\r\n  // showCurrentNum(indexSlide);\r\n  // sliderNextBtn.addEventListener('click', ()=> {\r\n  //   // сначала проверяем индекс - if можно перенести в ф. ShowSlide\r\n  //   if(indexSlide >= offerSlide.length-1){\r\n  //     indexSlide = 0; \r\n  //     showSlide(indexSlide);\r\n  //   }  else {\r\n  //     showSlide(indexSlide+1 );\r\n  //     indexSlide++;\r\n  //   }\r\n  //   showCurrentNum(indexSlide);\r\n  // });\r\n  // console.log(offerSlide.length); //4\r\n  // sliderPrevBtn.addEventListener('click', ()=> { \r\n  //   if(indexSlide <= 0){\r\n  //     indexSlide = offerSlide.length-1; \r\n  //     showSlide(indexSlide);\r\n  //   }  else {\r\n  //     showSlide(indexSlide-1 );\r\n  //     indexSlide--;\r\n  //   }\r\n  // showCurrentNum(indexSlide);\r\n  // });\r\n  // console.log(currentNum.innerHTML = '');\r\n}\r\n\r\nmodule.exports = slider;","function tabs() { \r\n  const tabs = document.querySelectorAll('.tabheader__item');\r\nconst tabsContent = document.querySelectorAll('.tabcontent');\r\nconst tabsParent = document.querySelector('.tabheader__items');\r\n//функция скрытия табов  и класса выделения текста\r\nfunction hideTabContent() {\r\n  tabsContent.forEach(item => { \r\n    item.style.display = 'none'; \r\n   });\r\n   tabs.forEach(item => { \r\n     item.classList.remove('tabheader__item_active'); \r\n    });\r\n }\r\nhideTabContent();\r\n// ф. показа табов\r\nfunction showTabContent(i=0) { \r\n  tabsContent[i].style.display = 'block';\r\n  tabs[i].classList.add('tabheader__item_active');\r\n}\r\nshowTabContent(); // показали первый таб при загрузке страницы\r\n// создаем обработчик для показа нужного Таба\r\ntabsParent.addEventListener('click', (e)=> {\r\n  //для e.target создаем переменную\r\n  const target = e.target;\r\n  if(target.classList.contains('tabheader__item')) {\r\n    tabs.forEach((item, i) => { \r\n      if(target == item) {\r\n        hideTabContent();\r\n        showTabContent(i);\r\n      }\r\n     });\r\n}\r\n});\r\n \r\n}\r\n\r\nmodule.exports = tabs;","function timer() { \r\n \r\n// Таймер обратного отсчета времени Акции\r\n// создаем дату конца акции\r\nlet deadLine = '2022-07-17T00:00:00+0300'; // так добавляет к текущему времени 3 часа\r\n// Функ. которая будет определять разницу между deadline и текущим временем временем\r\nfunction getTimerRemaining (endtime) { \r\n  let t = Date.parse(endtime) - Date.parse(new Date()); // получаем разницу в милисекундах между концом и текущим\r\n  // console.log(t);\r\n  // Теперь нам надо получить из милисекунд дни, часы, мин и сек.\r\n  let days = Math.floor( t / (24*3600*1000)); //  у Кантора см. расчет мой\r\n  // console.log(days); // 10\r\n  let hours = Math.floor( t / ( 60 * 60 * 1000) % 24)  ;\r\n  // console.log(hours);\r\n  let minutes = Math.floor(t / (60 * 1000) % 60);\r\n  // let minutes2 = Math.floor((t / 60 / 1000) % 60); // или так\r\n// console.log(minutes);\r\n let seconds = Math.floor(t / (1000) % 60);\r\n  // console.log(seconds);\r\n  //выводим данные наружу в виде объекта \r\n  return {\r\n'total': t,\r\n'days': days,\r\n'hours': hours,\r\n'minutes': minutes,\r\n'seconds': seconds,\r\n  };\r\n}\r\n//функция добавления нулей перед числами до 10\r\nfunction getZero(num) { \r\n  if(num > 0 && num <10) {\r\n    return `0${num}`;\r\n  } else {\r\n    return num;\r\n  } \r\n}\r\n//Создаем ф. которая устанавливает таймер на страницу\r\nfunction setClock(selector, endtime) { \r\n  //передаем класс timer в виде переменной\r\n  const timer = document.querySelector(selector);\r\n  //теперь уже находим идентификаторы внутри класса timer\r\n  const days = timer.querySelector('#days');\r\n  const hours = timer.querySelector('#hours');\r\n  const minutes = timer.querySelector('#minutes');\r\n  const seconds = timer.querySelector('#seconds');\r\n  let timeInterval = setInterval(updateClock, 1000);\r\n  //внутри ф. создаем ф. которая будет обновлять данные часов\r\n  function updateClock() { \r\n    // получаем объект из  \r\n   let t = getTimerRemaining(endtime);\r\n   days.innerHTML = getZero(t.days);\r\n   hours.innerHTML = getZero(t.hours);\r\n   minutes.innerHTML = getZero(t.minutes);\r\n   seconds.innerHTML = getZero(t.seconds);\r\n   //следим когда время выйдет\r\n   if (t.total <= 0) {\r\n     clearInterval(timeInterval);\r\n   }\r\n  }\r\n}\r\nsetClock('.timer', deadLine ); // deadline далее в параметрах как endtime везде\r\n}\r\n\r\nmodule.exports = timer;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","window.addEventListener('DOMContentLoaded', ()=> {\nlet tabs = require('./modules/tabs'),\n    modal = require('./modules/modal'),\n    timer = require('./modules/timer'),\n    cards = require('./modules/cards'),\n    slider = require('./modules/slider'),\n    forms = require('./modules/forms');\n\n\ntabs();\nmodal();\ntimer();\ncards();\nslider();\nforms();\n\n}); //конец loaded"],"names":[],"sourceRoot":""}